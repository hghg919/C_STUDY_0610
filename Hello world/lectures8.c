/* 
   작성자   : 정현준
*  작성일   : 2024-6-19

*  첫번째 학습목표 : 코드로 2진법 10진법 16진법 작성해서 데이터로 넘겨주기
*/

/*
* 2진수, 8진수, 16진수로 표현하는 법
* 2진수 : "0b"2진수로 표현 : 0b(+)1010; => 10(2진수로 10을 표현)
* 8진수 : "0" 17 8진수로 표현
* 10진수 : 10진법 표현. 0. 10진법으로 표현한 값.
* 16진수 : "0x"A 
* 
* pirntf로 8진수 표현 %o, 16진수 표현 %x
* 
* float 실수. 소수점
* 
* 소수를 표현하는 방법
* 첫번째 방식. 비트를 n : m 으로 분할한 후, n만큼 정수로 사용하고, m만큼 소수 부분으로 사용하자
* 문제점 : 소수를 자세히 표현하고자 할려면, 정수를 표현할 공간이 너무 적어진다.
* 소수를 정수표현 방식으로 사용하지 말고, 2e-1(2의 -1승), 2e-2, 2e-3 자리수에 0 또는 1 그더해서 표현하는 방식 도입
* 고정 소수점 방식(fixed point) : 정수를 표현하는 비트 수와 소수를 표현하는 비트 수를 고정시켜서 표현하는 방식.
* 부동 소수점 방식(float point) : 소수를 표현하는 방식으로, 정수 부분과 소수 부분의 비율에 따라 소수점을 출력하는 위치를 변경하는 방식.
*/

// 8.625를 실수로 표현해보기. 0b100.101
// 6.6225555555555555;

// 비트 포현 방식

// 비트 부호 : &, |, ^, ~
// 비트 이동(shift) 부호 : >>, <<

// a & b : AND 연산
//         1 & 0 = 0;
//         0 & 1 = 0;
//         0 & 0 = 0;
//         1 & 1 = 1;

// A | B : OR 연산
//         1 | 0 = 1;
//         0 | 1 = 1;
//         0 | 0 = 0;
//         1 | 1 = 1;

// a ^ b : XOR 연산
//         0b1000
//         0b1100
//         0b0100

// a ~ 반전 : 2의 보수 0b0001 -> 1110
// int num;
// num = ~num; // 비트 반전시킨다.

// 비트 간의 이동 연산자
// 8<<2;
//      char 0b00000100; << 2    8<<2(2e2) = 4 -> 32
//           0b00010000;
// 32>>3;    0b00010000; >> 3    32>>3 -> 2
//           0b00000010; 

#include "lectures.h"

void lectures8()
{
	// 변수 이름 정수 a_num 선언한 후, 숫자 15를 넣어서 출력
	int a_num = 15;
	printf("a_num의 값 : %d\n\n", a_num);

	a_num = 017;
	printf("a_num의 8진수 표현 값을 10진수로 출력 : %o\n", a_num);

	a_num = 0xF;
	printf("a_num의 16진수 표현 값을 10진수로 출력 : %x\n", a_num);

	a_num = 0b1111;
	printf("a_num의 2진수 표현 값을 10진수로 출력 : %d\n\n", a_num);

	//쉽게 달성하신 분은 도전해보세요.
	//%d 대신 %o, %x 출력해보기

	//문제1. -255 (진수로 표현해보자)

	int b_num = -255; // 255를 2의 보수한 값
	                  // 255를 2진법으로 표현 : 0b 00000000 00000000 00000000 11111111
	                  // 255를 표현한 반전 : 0b 11111111 11111111 11111111 00000001
	b_num = 0b11111111111111111111111100000001;

	printf("b_num 값 : %d\n\n", b_num);

	float a_float = 0.25;
	printf("a_float의 출력 %f\n\n", a_float);

	// 0.1 + 0.2가 0.3과 같은지 관계 연산자로 표현을 해보세요.
	// true면 1을 출, false면 0을 출력합니다.
	// int bool; 정수선언 0.1 + 0.2 0.3과 같은지

	printf("부동 소수점의 에러\n");
	int bool = (0.1 + 0.2) == 0.3; // 0.1 + 0.2값이 0.3이 아니다.
	printf("참이면 1 거짓이면 0을 출력합니다. 0.1 + 0.2 = 0.3? %d \n\n", bool);

	float c_num = 0.0;

	for(int number = 0; number < 30; number++) //반복문?
	c_num += 0.1;

	printf("c_num 0.1을 30번 더한 값이 무엇인가요? %f \n\n", c_num);

	printf("비트 연산 문제\n");

	// 두 개의 정수 변수에 2진수 표현된 값이 있다. d와 e의 비트 연산 결과를 기호를 사용하지 않고 출력해보세요. 
	int d = 0b00001111;
	int e = 0b00010010;
	int my_int = 0b00000010;
	int result = d & e;
	printf("내가 계산한 값 %d 실제값 %d\n", my_int, result);

	d = 0b00001111;
	e = 0b00010010;
	my_int = 0b00011111;
	result = d | e;
	printf("내가 계산한 값 %d 실제값 %d\n", my_int, result);

	d = 0b00001111;
	e = 0b00010010;
	my_int = 0b00011101;
	result = d ^ e;
	printf("내가 계산한 값 %d 실제값 %d\n\n", my_int, result);

	char overflowedvalue = 0b01000000;
	//                     0b01000000; << 1 => 0b10000000; -128
	// 2의 보수 반전 + 1;   0b01111111; => 0b10000000; 128
	// char 1바이트 크기.. 표현할 수 있는 수의 범위?
	// 1바이트 정수.. 표현할 수 있는 음수 범위, 양수 범위
	// 양의 정수 범위 : 0b[0][000][0000] ~ 0b[0][111][1111] : 0, 1 ~ 127
	// 음의 정수 범위 : 0b[1][000][0000] ~ 0b[1][111][1111] : -128 ~ -1
	// -128 ~ 127 (-128 ~ 127) 256(2e8) 

	// 0b01000000; << 2;
	// overflowedvalue = 0b100000000; => 00000000 = 0?
	//                   0b000000100; >> 8 => 0

	overflowedvalue << 2; // 어떤 값이 나올까요? 왜 그런 값이 나올까요? 256
	//printf 출력해보기
	printf("0b01000000 << 2 의 값 : %d\n", overflowedvalue);

	overflowedvalue = 0b00000100;
	overflowedvalue >> 5; // 어떤 값이 나올까요? 왜 그런 값이 나올까요? 0
	//printf 출력해보기
	printf("0b00000100 >> 5 의 값 : %d\n\n", overflowedvalue);

	//10진수 하나 입력 받아서, 해당수의 2의 보수 값을 출력하는 코드를 작성해보세요. (~)연산자 사용해서.
	int twocomplement;
	scanf_s("%d", &twocomplement);
	twocomplement = ~twocomplement + 1;

	printf("2의 보수의 값을 출력 : %d\n", twocomplement);

	//시프트 연산
	//10진수 하나 입력 받아서, 해당 수에 8을 곱한후 32로 나누는 코드를 x,/ 없이 작성해보세요.
	//8과 32가 반드시 코드에 들어가도록, 비트 연산자(<<, >>) 사용할 것.
	char shiftnum = 64; //4
	//0b01000000;
	//scanf_s("%d", &shiftnum);
	//shiftnum <<= 3;
	//shiftnum = shiftnum <<3 >>5; //8을 곱한 후 32로 나눈다.
	shiftnum = shiftnum << 3;
	shiftnum = shiftnum >> 5;
	printf("8을 곱한 후 32로 나눈 값 : %d", shiftnum);
}